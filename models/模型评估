from sklearn.metrics import (accuracy_score, recall_score, precision_score, 
                           f1_score, balanced_accuracy_score, confusion_matrix, 
                           roc_auc_score, roc_curve, classification_report)
from sklearn.model_selection import cross_val_score, StratifiedKFold

def evaluate_model(model, X_test, y_test, y_pred, y_pred_proba, model_name):
    """全面评估模型性能"""
    accuracy = accuracy_score(y_test, y_pred)
    sensitivity = recall_score(y_test, y_pred)
    precision_val = precision_score(y_test, y_pred)
    f1 = f1_score(y_test, y_pred)
    balanced_acc = balanced_accuracy_score(y_test, y_pred)
    
    tn, fp, fn, tp = confusion_matrix(y_test, y_pred).ravel()
    specificity = tn / (tn + fp)
    auc = roc_auc_score(y_test, y_pred_proba)
    
    print(f"{model_name} 性能:")
    print(f"  准确性: {accuracy:.4f}")
    print(f"  平衡准确性: {balanced_acc:.4f}")
    print(f"  敏感性: {sensitivity:.4f}")
    print(f"  特异性: {specificity:.4f}")
    print(f"  精确率: {precision_val:.4f}")
    print(f"  F1分数: {f1:.4f}")
    print(f"  AUC: {auc:.4f}")
    
    return {
        'Accuracy': accuracy,
        'Balanced_Accuracy': balanced_acc,
        'Sensitivity': sensitivity,
        'Specificity': specificity,
        'Precision': precision_val,
        'F1-Score': f1,
        'AUC': auc
    }

def cross_validate_model(model, X_train, y_train, cv_folds=5):
    """交叉验证评估"""
    cv = StratifiedKFold(n_splits=cv_folds, shuffle=True, random_state=42)
    
    if hasattr(model, 'named_steps') and 'classifier' in model.named_steps:
        cv_model = model.named_steps['classifier']
        # 需要先预处理数据
        if hasattr(model, 'named_steps') and 'preprocessor' in model.named_steps:
            preprocessor = model.named_steps['preprocessor']
            X_train_processed = preprocessor.fit_transform(X_train)
            cv_scores = cross_val_score(cv_model, X_train_processed, y_train, cv=cv, scoring='roc_auc')
        else:
            cv_scores = cross_val_score(cv_model, X_train, y_train, cv=cv, scoring='roc_auc')
    else:
        cv_scores = cross_val_score(model, X_train, y_train, cv=cv, scoring='roc_auc')
    
    cv_mean = cv_scores.mean()
    cv_std = cv_scores.std()
    
    print(f"  {cv_folds}折交叉验证 AUC: {cv_mean:.4f} (+/- {cv_std * 2:.4f})")
    
    return cv_mean, cv_std

def compute_class_weights(y_train):
    """计算类别权重"""
    from sklearn.utils.class_weight import compute_class_weight
    class_weights = compute_class_weight('balanced', classes=np.unique(y_train), y=y_train)
    class_weight_dict = dict(zip(np.unique(y_train), class_weights))
    print(f"类别权重: {class_weight_dict}")
    return class_weight_dict
